{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3 en xarxa i intel\u00b7lig\u00e8ncia artificial","text":"<p>Benvinguts al curs de Programaci\u00f3 en Xarxa i Intel\u00b7lig\u00e8ncia Artificial! Aquest curs est\u00e0 dissenyat per proporcionar-vos els coneixements i habilitats necessaris per desenvolupar aplicacions que integrin tecnologies de xarxa amb t\u00e8cniques d'intel\u00b7lig\u00e8ncia artificial.</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/","title":"2.1 Introducci\u00f3 al pathfinding","text":"<p>El pathfinding \u00e9s una t\u00e8cnica utilitzada en intel\u00b7lig\u00e8ncia artificial per a determinar la millor ruta entre dos punts en un entorn. Aquesta t\u00e8cnica \u00e9s especialment \u00fatil en videojocs, on els personatges controlats per l'ordinador (NPCs) necessiten moure's de manera eficient i realista dins del m\u00f3n del joc.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/#algorismes-de-pathfinding","title":"Algorismes de pathfinding","text":"<p>Hi ha diversos algorismes de pathfinding, per\u00f2 els m\u00e9s comuns s\u00f3n:</p> <ol> <li>Dijkstra: Un algorisme que troba el cam\u00ed m\u00e9s curt en un graf, encara que pot ser menys eficient que A* en entorns grans.</li> <li>Algorisme A*: Un dels algorismes m\u00e9s populars i eficients. Utilitza una heur\u00edstica per guiar la cerca de camins.</li> </ol>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/#grafs-i-nodes","title":"Grafs i nodes","text":"<p>Un graf \u00e9s una estructura de dades composta per nodes (o v\u00e8rtexs) i arestes (o connexions) que representen les relacions entre els nodes. En el context del pathfinding, els nodes representen punts en l'espai, i les arestes representen les connexions possibles entre aquests punts.</p> <p></p> <p>Existeixen diferents tipus de grafs:</p> <ul> <li>Grafs etiquetats: On les arestes tenen pesos associats que representen el cost de moure's entre nodes.</li> <li>Grafs dirigits: On les connexions entre nodes tenen una direcci\u00f3 espec\u00edfica.</li> </ul> <p></p> <p></p> <p>Un graf pot estar etiquetat i ser dirigit al mateix temps:</p> <p></p> <p>Una aplicaci\u00f3 comuna de la te\u00f2ria de grafs \u00e9s el c\u00e0lcul de rutes en sistemes de navegaci\u00f3, on els nodes representen interseccions i les arestes representen carreteres amb diferents costos (dist\u00e0ncies, temps de viatge, etc.).</p> <p></p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/#algorisme-de-dijkstra","title":"Algorisme de Dijkstra","text":"<p>L'algorisme de Dijkstra \u00e9s un algorisme de cerca de camins que troba el cam\u00ed m\u00e9s curt des d'un node d'origen fins a tots els altres nodes en un graf amb pesos no negatius. Funciona assignant un cost acumulat a cada node i actualitzant aquest cost a mesura que es troben camins m\u00e9s curts.</p> <p>L'algorisme segueix aquests passos b\u00e0sics:</p> <ol> <li>Inicialitza tots els nodes amb un cost infinit, excepte el node d'origen que s'inicialitza amb un cost de zero.</li> <li>Marca tots els nodes com a no visitats.</li> <li>Selecciona el node no visitat amb el cost m\u00e9s baix com a node actual.</li> <li>Actualitza els costos dels nodes ve\u00efns del node actual.</li> <li>Marca el node actual com a visitat.</li> <li>Repeteix els passos 3-5 fins que tots els nodes hagin estat visitats.</li> </ol> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/#algorisme-a","title":"Algorisme A*","text":"<p>L'algorisme A* \u00e9s una extensi\u00f3 de l'algorisme de Dijkstra que utilitza una heur\u00edstica per guiar la cerca de camins. Aquesta heur\u00edstica estima el cost restant des del node actual fins al node de destinaci\u00f3, permetent a l'algorisme prioritzar els nodes que semblen m\u00e9s prometedors.</p> <p>En el cas del pathfinding en un entorn 2D, una heur\u00edstica comuna \u00e9s la dist\u00e0ncia entre dos punts.</p> <p>L'algorisme A* segueix aquests passos b\u00e0sics:</p> <ol> <li>Inicialitza tots els nodes amb un cost infinit, excepte el node d'origen que s'inicialitza amb un cost de zero.</li> <li>Marca tots els nodes com a no visitats.</li> <li>Selecciona el node no visitat amb el cost total m\u00e9s baix (cost acumulat + heur\u00edstica) com a node actual.</li> <li>Actualitza els costos dels nodes ve\u00efns del node actual.</li> <li>Marca el node actual com a visitat.</li> <li>Repeteix els passos 3-5 fins que s'arribe al node de destinaci\u00f3 o no hi hagi m\u00e9s nodes per explorar.</li> </ol> <p>Comparaci\u00f3 entre Dijkstra i A*:</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/","title":"2.2 Pathfinding 2D","text":"<p>En aquesta secci\u00f3, explorarem els conceptes b\u00e0sics del pathfinding en un entorn 2D, treballant amb un videojoc cl\u00e0ssic.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#configuracio-del-projecte","title":"Configuraci\u00f3 del projecte","text":"<p>Descarregueu el projecte base des del seg\u00fcent enlla\u00e7: Enlla\u00e7 al projecte base.</p> <p>Un cop descarregat, obriu-lo amb Unity. Veureu que \u00e9s el cl\u00e0ssic Pacman.</p> <p></p> <p>Ara, descarregueu el paquet del A* Pathfinding Project des del seg\u00fcent enlla\u00e7:</p> <ul> <li>A* Pathfinding Project</li> </ul> <p>Descarregueu la versi\u00f3 gratu\u00efta.</p> <p>Importeu el paquet descarregat al vostre projecte de Unity, fent doble click o arrossegant-lo a la finestra de Unity dins de la carpeta \"Packages\". Deixeu totes les opcions per defecte seleccionades i feu click a \"Import\".</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#afegir-component-de-pathfinding","title":"Afegir component de pathfinding","text":"<p>Per afegir el component de pathfinding al vostre escenari, primer creem un GameObject buit. Nomeneu-lo \"A*\".</p> <p>Seleccioneu el GameObject \"A*\" i feu click a \"Add Component\". Cerqueu \"Pathfinder\" i afegiu-lo.</p> <p>Dins del component Pathfinder, feu click a Graphs -&gt; Add New Graph -&gt; Grid Graph.</p> <p>Dins de les propietats del Grid Graph, ajusteu els seg\u00fcents par\u00e0metres:</p> <ul> <li>Grid Graph 2D: activat</li> </ul> <p>Ara apareixer\u00e0 una graella sobre el vostre escenari. Ajusteu la mida i la posici\u00f3 de la graella perqu\u00e8 cobreixi tota l'\u00e0rea on voleu que els personatges es puguen moure, usant l'eina scale.</p> <p>Configureu tamb\u00e9  les seg\u00fcents opcions:</p> <ul> <li>Connections: Four. Aix\u00f2 far\u00e0 que cada quadrat de la graella estigui connectat nom\u00e9s amb els seus 4 ve\u00efns (dalt, baix, esquerra, dreta).</li> <li>Use 2D Physics: activat. Aix\u00f2 far\u00e0 que el pathfinding utilitzi la f\u00edsica 2D per detectar obstacles.</li> <li>Collider type: Sphere.</li> <li>Diameter: 0.5. Aix\u00f2 defineix la mida de l'esfera que s'utilitzar\u00e0 per detectar col\u00b7lisions amb obstacles.</li> <li>Obstacle layer mask: Obstacle. Aix\u00f2 far\u00e0 que el pathfinding considere com a obstacles tots els objectes que estiguin en la capa \"Obstacle\".</li> <li>Height testing: desactivat. Aix\u00f2 desactiva la comprovaci\u00f3 d'altura, ja que estem treballant en 2D.</li> </ul> <p></p> <p>Un cop fet aix\u00f2, feu click a \"Scan\" per generar el graf de navegaci\u00f3. Us haur\u00e0 generat una graella blava sobre l'escenari amb els possibles camins.</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#afegir-components-de-pathfinding-als-fantasmes","title":"Afegir components de pathfinding als fantasmes","text":"<p>Selecioneu el fantasma roig (Ghost_blinky) i feu click a \"Add Component\". Cerqueu \"AIPath (2D,3D)\" i afegiu-lo. Veureu q    ue us ha afegit dos components nous: AIPath i Seeker.</p> <p>En el component AIPath, configureu els seg\u00fcents par\u00e0metres:</p> <ul> <li>Orientation: Y-axis forward (for 2D games).</li> <li>Max Speed: 7.</li> <li>Enable rotation: desactivat.</li> </ul> <p>Ara afegiu un component m\u00e9s: feu click a \"Add Component\", cerqueu \"AI Destination Setter\" i afegiu-lo. Afegiu el gameobject Pacman al camp Target del component.</p> <p>Si poseu en marxa el joc, veureu que el fantasma comen\u00e7a a perseguir el Pacman utilitzant el pathfinding.</p> <p>N'hi ha 3 par\u00e0metres m\u00e9s que podem ajustar:</p> <ul> <li>Slowdown distance: dist\u00e0ncia a la qual el fantasma comen\u00e7a a frenar quan s'acosta a la seva destinaci\u00f3: 0.</li> <li>Pick next waypoint distance: dist\u00e0ncia a la qual el fantasma considera que ha arribat a un punt de pas i comen\u00e7a a moure's cap al seg\u00fcent: 2.</li> <li>End reached distance: dist\u00e0ncia a la qual el fantasma considera que ha arribat a la seva destinaci\u00f3 final: 2.5.</li> </ul> <p></p> <p>Si poseu en marxa el joc, veureu que el fantasma persegueix el Pacman utilitzant el pathfinding. Fixeu-vos en el gizmo que marca el cam\u00ed que est\u00e0 seguint el fantasma.</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#programacio-de-la-ia-per-codi","title":"Programaci\u00f3 de la IA per codi","text":"<p>En aquest apartat, programarem la IA del fantasma per codi, en lloc d'utilitzar el component AI Destination Setter.</p> <p>Fes una c\u00f2pia del fantasma roig (Ghost_blinky) i desactiva l'anterior. Treballarem en la c\u00f2pia. Elimina els components AI Destination Setter i AIPath. Obre l'script GhostController.cs.</p> <p>Actualitza tamb\u00e9 la refer\u00e8ncia al fantasma dins del script GameController.cs per a que apunte a la c\u00f2pia que acabes de crear.</p> <p></p> <p>Abans de comen\u00e7ar a treballar amb una nova biblioteca, \u00e9s una bona idea consultar la seua documentaci\u00f3 oficial. Pots consultar la documentaci\u00f3 de l'A* Pathfinding Project ac\u00ed: Documentaci\u00f3 A* Pathfinding Project.</p> <p>Les classes m\u00e9s importants s\u00f3n:</p> <ul> <li>Seeker: s'encarrega de calcular els camins.</li> <li>Path: representa un cam\u00ed calculat. Podem accedir als punts del cam\u00ed a trav\u00e9s de la propietat <code>vectorPath</code>.</li> </ul> <p>El primer ser\u00e0 importar el namespace <code>Pathfinding</code>:</p> <pre><code>using Pathfinding;\n</code></pre> <p>Despr\u00e9s crearem propietats p\u00fabliques per a l'objectiu (Pacman) i per al pr\u00f2xim punt de cerca (dist\u00e0ncia a partir de la qual cercar\u00e0 el pr\u00f2xim punt):</p> <pre><code>public Transform target;\npublic float nextWaypointDistance = 3f;\n</code></pre> <p>Tamb\u00e9 necessitarem propietats privades per al cam\u00ed (<code>Path</code>), per al punt actual del cam\u00ed i un boole\u00e0 per saber si hem arribat al final del cam\u00ed. Tamb\u00e9 necessitarem una refer\u00e8ncia al component <code>Seeker</code>:</p> <pre><code>private Path path;\nprivate Seeker seeker;\nprivate int currentWaypoint = 0;\nprivate bool reachedEndOfPath = false;\n</code></pre> <p>A continuaci\u00f3, inicialitzarem la refer\u00e8ncia al <code>Seeker</code> dins del m\u00e8tode <code>Start()</code> i comen\u00e7arem a cercar el cam\u00ed cap a l'objectiu usant el m\u00e8tode <code>StartPath()</code> on indiquem la posici\u00f3 inicial, la posici\u00f3 final i la funci\u00f3 que es cridar\u00e0 quan s'acabe de calcular el cam\u00ed:</p> <pre><code>seeker = GetComponent&lt;Seeker&gt;();\nseeker.StartPath(transform.position, target.position, OnPathComplete);\n</code></pre> <p>Ara creem el m\u00e8tode <code>OnPathComplete()</code> que s'encarregar\u00e0 de rebre el cam\u00ed calculat i assignar-lo a la propietat <code>path</code>. Tamb\u00e9 reiniciarem l'\u00edndex del punt actual del cam\u00ed:</p> <pre><code>public void OnPathComplete(Path p)\n{\n// The path is now calculated!\n\n//Check for errors\nif (p.error)\n{\nDebug.LogError(\"Error calculating path: \" + p.errorLog);\nreturn;\n}\n\npath = p; // Store the calculated path\ncurrentWaypoint = 0; // Reset waypoint index\n\n}\n</code></pre> <p>En l'inspector de Unity, assigna el Pacman a la propietat Target del fantasma. Posa en marxa el joc i comprova que es dibuixa el cam\u00ed des del fantasma fins al Pacman. Per\u00f2 de moment aquest no s'actualitza.</p>"}]}