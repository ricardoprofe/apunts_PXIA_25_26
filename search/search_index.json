{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3 en xarxa i intel\u00b7lig\u00e8ncia artificial","text":"<p>Benvinguts al curs de Programaci\u00f3 en Xarxa i Intel\u00b7lig\u00e8ncia Artificial! Aquest curs est\u00e0 dissenyat per proporcionar-vos els coneixements i habilitats necessaris per desenvolupar aplicacions que integrin tecnologies de xarxa amb t\u00e8cniques d'intel\u00b7lig\u00e8ncia artificial.</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/","title":"2.1 Introducci\u00f3 al pathfinding","text":"<p>El pathfinding \u00e9s una t\u00e8cnica utilitzada en intel\u00b7lig\u00e8ncia artificial per a determinar la millor ruta entre dos punts en un entorn. Aquesta t\u00e8cnica \u00e9s especialment \u00fatil en videojocs, on els personatges controlats per l'ordinador (NPCs) necessiten moure's de manera eficient i realista dins del m\u00f3n del joc.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/#algorismes-de-pathfinding","title":"Algorismes de pathfinding","text":"<p>Hi ha diversos algorismes de pathfinding, per\u00f2 els m\u00e9s comuns s\u00f3n:</p> <ol> <li>Dijkstra: Un algorisme que troba el cam\u00ed m\u00e9s curt en un graf, encara que pot ser menys eficient que A* en entorns grans.</li> <li>Algorisme A*: Un dels algorismes m\u00e9s populars i eficients. Utilitza una heur\u00edstica per guiar la cerca de camins.</li> </ol>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/#grafs-i-nodes","title":"Grafs i nodes","text":"<p>Un graf \u00e9s una estructura de dades composta per nodes (o v\u00e8rtexs) i arestes (o connexions) que representen les relacions entre els nodes. En el context del pathfinding, els nodes representen punts en l'espai, i les arestes representen les connexions possibles entre aquests punts.</p> <p></p> <p>Existeixen diferents tipus de grafs:</p> <ul> <li>Grafs etiquetats: On les arestes tenen pesos associats que representen el cost de moure's entre nodes.</li> <li>Grafs dirigits: On les connexions entre nodes tenen una direcci\u00f3 espec\u00edfica.</li> </ul> <p></p> <p></p> <p>Un graf pot estar etiquetat i ser dirigit al mateix temps:</p> <p></p> <p>Una aplicaci\u00f3 comuna de la te\u00f2ria de grafs \u00e9s el c\u00e0lcul de rutes en sistemes de navegaci\u00f3, on els nodes representen interseccions i les arestes representen carreteres amb diferents costos (dist\u00e0ncies, temps de viatge, etc.).</p> <p></p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/#algorisme-de-dijkstra","title":"Algorisme de Dijkstra","text":"<p>L'algorisme de Dijkstra \u00e9s un algorisme de cerca de camins que troba el cam\u00ed m\u00e9s curt des d'un node d'origen fins a tots els altres nodes en un graf amb pesos no negatius. Funciona assignant un cost acumulat a cada node i actualitzant aquest cost a mesura que es troben camins m\u00e9s curts.</p> <p>L'algorisme segueix aquests passos b\u00e0sics:</p> <ol> <li>Inicialitza tots els nodes amb un cost infinit, excepte el node d'origen que s'inicialitza amb un cost de zero.</li> <li>Marca tots els nodes com a no visitats.</li> <li>Selecciona el node no visitat amb el cost m\u00e9s baix com a node actual.</li> <li>Actualitza els costos dels nodes ve\u00efns del node actual.</li> <li>Marca el node actual com a visitat.</li> <li>Repeteix els passos 3-5 fins que tots els nodes hagin estat visitats.</li> </ol> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.1.%20Introducci%C3%B3%20al%20pathfinding%20copy/#algorisme-a","title":"Algorisme A*","text":"<p>L'algorisme A* \u00e9s una extensi\u00f3 de l'algorisme de Dijkstra que utilitza una heur\u00edstica per guiar la cerca de camins. Aquesta heur\u00edstica estima el cost restant des del node actual fins al node de destinaci\u00f3, permetent a l'algorisme prioritzar els nodes que semblen m\u00e9s prometedors.</p> <p>En el cas del pathfinding en un entorn 2D, una heur\u00edstica comuna \u00e9s la dist\u00e0ncia entre dos punts.</p> <p>L'algorisme A* segueix aquests passos b\u00e0sics:</p> <ol> <li>Inicialitza tots els nodes amb un cost infinit, excepte el node d'origen que s'inicialitza amb un cost de zero.</li> <li>Marca tots els nodes com a no visitats.</li> <li>Selecciona el node no visitat amb el cost total m\u00e9s baix (cost acumulat + heur\u00edstica) com a node actual.</li> <li>Actualitza els costos dels nodes ve\u00efns del node actual.</li> <li>Marca el node actual com a visitat.</li> <li>Repeteix els passos 3-5 fins que s'arribe al node de destinaci\u00f3 o no hi hagi m\u00e9s nodes per explorar.</li> </ol> <p>Comparaci\u00f3 entre Dijkstra i A*:</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/","title":"2.2 Pathfinding 2D","text":"<p>En aquesta secci\u00f3, explorarem els conceptes b\u00e0sics del pathfinding en un entorn 2D, treballant amb un videojoc cl\u00e0ssic.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#configuracio-del-projecte","title":"Configuraci\u00f3 del projecte","text":"<p>Descarregueu el projecte base des del seg\u00fcent enlla\u00e7: Enlla\u00e7 al projecte base.</p> <p>Un cop descarregat, obriu-lo amb Unity. Veureu que \u00e9s el cl\u00e0ssic Pacman.</p> <p></p> <p>Ara, descarregueu el paquet del A* Pathfinding Project des del seg\u00fcent enlla\u00e7:</p> <ul> <li>A* Pathfinding Project</li> </ul> <p>Descarregueu la versi\u00f3 gratu\u00efta.</p> <p>Importeu el paquet descarregat al vostre projecte de Unity, fent doble click o arrossegant-lo a la finestra de Unity dins de la carpeta \"Packages\". Deixeu totes les opcions per defecte seleccionades i feu click a \"Import\".</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#afegir-component-de-pathfinding","title":"Afegir component de pathfinding","text":"<p>Per afegir el component de pathfinding al vostre escenari, primer creem un GameObject buit. Nomeneu-lo \"A*\".</p> <p>Seleccioneu el GameObject \"A*\" i feu click a \"Add Component\". Cerqueu \"Pathfinder\" i afegiu-lo.</p> <p>Dins del component Pathfinder, feu click a Graphs -&gt; Add New Graph -&gt; Grid Graph.</p> <p>Dins de les propietats del Grid Graph, ajusteu els seg\u00fcents par\u00e0metres:</p> <ul> <li>Grid Graph 2D: activat</li> </ul> <p>Ara apareixer\u00e0 una graella sobre el vostre escenari. Ajusteu la mida i la posici\u00f3 de la graella perqu\u00e8 cobreixi tota l'\u00e0rea on voleu que els personatges es puguen moure, usant l'eina scale.</p> <p>Configureu tamb\u00e9  les seg\u00fcents opcions:</p> <ul> <li>Connections: Four. Aix\u00f2 far\u00e0 que cada quadrat de la graella estigui connectat nom\u00e9s amb els seus 4 ve\u00efns (dalt, baix, esquerra, dreta).</li> <li>Use 2D Physics: activat. Aix\u00f2 far\u00e0 que el pathfinding utilitzi la f\u00edsica 2D per detectar obstacles.</li> <li>Collider type: Sphere.</li> <li>Diameter: 0.5. Aix\u00f2 defineix la mida de l'esfera que s'utilitzar\u00e0 per detectar col\u00b7lisions amb obstacles.</li> <li>Obstacle layer mask: Obstacle. Aix\u00f2 far\u00e0 que el pathfinding considere com a obstacles tots els objectes que estiguin en la capa \"Obstacle\".</li> <li>Height testing: desactivat. Aix\u00f2 desactiva la comprovaci\u00f3 d'altura, ja que estem treballant en 2D.</li> </ul> <p></p> <p>Un cop fet aix\u00f2, feu click a \"Scan\" per generar el graf de navegaci\u00f3. Us haur\u00e0 generat una graella blava sobre l'escenari amb els possibles camins.</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#afegir-components-de-pathfinding-als-fantasmes","title":"Afegir components de pathfinding als fantasmes","text":"<p>Selecioneu el fantasma roig (Ghost_blinky) i feu click a \"Add Component\". Cerqueu \"AIPath (2D,3D)\" i afegiu-lo. Veureu que us ha afegit dos components nous: AIPath i Seeker.</p> <p>En el component AIPath, configureu els seg\u00fcents par\u00e0metres:</p> <ul> <li>Orientation: Y-axis forward (for 2D games).</li> <li>Max Speed: 7.</li> <li>Enable rotation: desactivat.</li> </ul> <p>Ara afegiu un component m\u00e9s: feu click a \"Add Component\", cerqueu \"AI Destination Setter\" i afegiu-lo. Afegiu el gameobject Pacman al camp Target del component.</p> <p>Si poseu en marxa el joc, veureu que el fantasma comen\u00e7a a perseguir el Pacman utilitzant el pathfinding.</p> <p>N'hi ha 3 par\u00e0metres m\u00e9s que podem ajustar:</p> <ul> <li>Slowdown distance: dist\u00e0ncia a la qual el fantasma comen\u00e7a a frenar quan s'acosta a la seva destinaci\u00f3: 0.</li> <li>Pick next waypoint distance: dist\u00e0ncia a la qual el fantasma considera que ha arribat a un punt de pas i comen\u00e7a a moure's cap al seg\u00fcent: 2.</li> <li>End reached distance: dist\u00e0ncia a la qual el fantasma considera que ha arribat a la seva destinaci\u00f3 final: 2.5.</li> </ul> <p></p> <p>Si poseu en marxa el joc, veureu que el fantasma persegueix el Pacman utilitzant el pathfinding. Fixeu-vos en el gizmo que marca el cam\u00ed que est\u00e0 seguint el fantasma.</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#programacio-de-la-ia-per-codi","title":"Programaci\u00f3 de la IA per codi","text":"<p>En aquest apartat, programarem la IA del fantasma per codi.</p> <p>Obre l'script GhostMovement.cs.</p> <p>Abans de comen\u00e7ar a treballar amb una nova biblioteca, \u00e9s una bona idea consultar la seua documentaci\u00f3 oficial. Pots consultar la documentaci\u00f3 de l'A* Pathfinding Project ac\u00ed: Documentaci\u00f3 A* Pathfinding Project.</p> <p>Les classes m\u00e9s importants s\u00f3n:</p> <ul> <li>Seeker: s'encarrega de calcular els camins.</li> <li>Path: representa un cam\u00ed calculat. Podem accedir als punts del cam\u00ed a trav\u00e9s de la propietat <code>vectorPath</code>.</li> <li>IAstarAI: interf\u00edcie que defineix les funcionalitats b\u00e0siques d'una entitat que utilitza el pathfinding.</li> <li>AIDestinationSetter: component que estableix la destinaci\u00f3 d'una entitat.</li> </ul> <p>El primer ser\u00e0 importar el namespace <code>Pathfinding</code>:</p> <pre><code>using Pathfinding;\n</code></pre> <p>Despr\u00e9s crearem 2 propietats p\u00fabliques per al Pacman i per a un punt de cera (target) que ser\u00e0 el pr\u00f2xim punt del cam\u00ed:</p> <pre><code>public Transform target;\npublic Transform pacman;\n</code></pre> <p>target ser\u00e0 el primer objectiu del fantasma; quan arribe a ell, el seg\u00fcent objectiu ser\u00e0 el Pacman.</p> <p>Tamb\u00e9 necessitem refer\u00e8ncies als components <code>IAstarAI</code> i <code>AIDestinationSetter</code>:</p> <pre><code>private IAstarAI ai;\nprivate AIDestinationSetter destinationSetter;\n</code></pre> <p><code>ai</code> ens proporciona les funcionalitats b\u00e0siques per a moure el fantasma, mentre que <code>destinationSetter</code> ens permetr\u00e0 establir la destinaci\u00f3 del fantasma.</p> <p>El seg\u00fcent pas ser\u00e0 inicialitzar aquestes refer\u00e8ncies dins del m\u00e8tode <code>Start()</code>:</p> <pre><code> private void Start()\n{\nai = GetComponent&lt;IAstarAI&gt;();\nai.destination = target.position;\n\ndestinationSetter = GetComponent&lt;AIDestinationSetter&gt;();\ndestinationSetter.target = target;\n\nResetState();\n}\n</code></pre> <p>Finalment, dins del m\u00e8tode <code>Update()</code>, comprovararem si el fantasma ha arribat al seu objectiu actual. Si \u00e9s aix\u00ed, actualitzarem l'objectiu a Pacman:</p> <pre><code>private void Update()\n{\nif(ai.reachedDestination){\nDebug.Log(\"Reached\");\ndestinationSetter.target = pacman.transform;\n}\n}\n</code></pre> <p>Ara hem de crear un GameObject buit dins de l'escena i anomenar-lo <code>target01</code>. Col\u00b7loca'l en el cant\u00f3 superior dreta de l'escena, en un lloc accessible per al fantasma. Despr\u00e9s, assigna aquest GameObject a la propietat Target del script GhostMovement del fantasma roig. Assigna tamb\u00e9 el Pacman a la propietat Pacman.</p> <p>Posa en marxa el joc i comprova que el fantasma es mou cap al punt de cerca primer i despr\u00e9s comen\u00e7a a perseguir el Pacman.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#afegint-punts-de-cerca","title":"Afegint punts de cerca","text":"<p>Ara afegirem m\u00e9s punts de cerca perqu\u00e8 el fantasma no vage directament al Pacman despr\u00e9s d'arribar al primer punt. La forma m\u00e9s eficient de fer-ho \u00e9s crear un array de punts de cerca i anar actualitzant l'objectiu a mesura que el fantasma arribe a cada punt.</p> <p>Actualitza les propietats p\u00fabliques per a que siguen un array de punts de cerca. Tamb\u00e9 necessitem una propietat privada per a portar el compte de l'\u00edndex del punt de cerca actual:</p> <pre><code>public Transform[] targets;\n\nprivate int currentTargetIndex = 0;\n</code></pre> <p>En l'inspector, crea un Empty Object anomenat <code>BlinkyTargets</code> i mou dins el <code>target_01</code>. Duplica el target per a crear 3 punts de cerca m\u00e9s (<code>target_02</code>, <code>target_03</code> i <code>target_04</code>). Col\u00b7loca'ls en diferents llocs de l'escena tal com s'indica en la imatge:</p> <p></p> <p>Tip</p> <p>Pots afegir als targets un component sprite renderer per a veure'ls millor en l'escena. Recorda desactivar aquest component abans de posar en marxa el joc.</p> <p>Assigna els 4 targets a l'array Targets del script GhostMovement del fantasma roig.</p> <p>Com estem treballant amb un array de punts de cerca, necessitem canviar la inicialitzaci\u00f3 del primer objectiu dins del m\u00e8tode <code>Start()</code>:</p> <pre><code>private void Start()\n{\nai = GetComponent&lt;IAstarAI&gt;();\nai.destination = targets[currentTargetIndex].position;\n\ndestinationSetter = GetComponent&lt;AIDestinationSetter&gt;();\ndestinationSetter.target = targets[currentTargetIndex];\n\nResetState();\n}\n</code></pre> <p>Per a actualitzar l'objectiu quan el fantasma arribe a un punt de cerca, actualitza el m\u00e8tode <code>Update()</code> de la seg\u00fcent manera:</p> <pre><code>private void Update()\n{\nif(ai.reachedDestination){\nif(currentTargetIndex == targets.Length - 1){\ndestinationSetter.target = pacman.transform;\n}\nelse\n{\ncurrentTargetIndex++;\ndestinationSetter.target = targets[currentTargetIndex];\n}\n}\n}\n</code></pre> <p>En aquest m\u00e8tode, comprovem si el fantasma ha arribat a la seva destinaci\u00f3 actual. Si \u00e9s aix\u00ed, verifiquem si l'\u00edndex del punt de cerca actual \u00e9s l'\u00faltim de l'array. Si ho \u00e9s, ha arribat al final de l'array i establim l'objectiu a Pacman. Si no ho \u00e9s, incrementem l'\u00edndex del punt de cerca i actualitzem l'objectiu al seg\u00fcent punt de cerca de l'array.</p> <p>Posa en marxa el joc i comprova que el fantasma es mou pels punts de cerca abans de perseguir el Pacman.</p> <p>Per finalitzar, hem de fer que el dest\u00ed s'actualitze despr\u00e9s de la mort del Pacman, quan es torne a iniciar el joc. Creem el m\u00e8tode <code>ResetDestination()</code> que s'encarregar\u00e0 de reiniciar l'\u00edndex del punt de cerca i establir el dest\u00ed al primer punt de cerca:</p> <pre><code>public void ResetDestination()\n{\ncurrentTargetIndex = 0;\ndestinationSetter.target = targets[currentTargetIndex];\n}\n</code></pre> <p>Aquest m\u00e8tode es cridar\u00e0 des del script Ghost.cs, dins del m\u00e8tode <code>ResetState()</code>:</p> <pre><code>//Ghost.cs\n\npublic void ResetState()\n{\ngameObject.SetActive(true);\nmovement.ResetState();\n\nfrightened.Disable();\nchase.Disable();\nscatter.Enable();\n\nmovement.ResetDestination(); //Afegeix esta l\u00ednia\n\nif (home != initialBehavior) {\nhome.Disable();\n}\n\nif (initialBehavior != null) {\ninitialBehavior.Enable();\n}\n}\n</code></pre> <p>Per \u00faltim, comprova que, en l'script GameManager.cs, dins del m\u00e8tode <code>ResetState()</code>, es crida el m\u00e8tode <code>ResetState()</code> del Pacman abans que el dels fantasmes, per evitar errors:</p> <pre><code>//GameManager.cs\n\nprivate void ResetState()\n{\npacman.ResetState();\n\nfor (int i = 0; i &lt; ghosts.Length; i++) {\nghosts[i].ResetState();\n}\n}\n</code></pre> <p>Ja est\u00e0! Posa en marxa el joc i comprova que, despr\u00e9s de la mort del Pacman, els fantasma roig torna a moure's pels punts de cerca abans de perseguir-lo de nou.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.2.%20Pathfinding%202D/#tasques","title":"Tasques","text":"<ul> <li>Crea la l\u00f2gica per a que quan el Pacman menge una pastilla de poder, el fantasma roig fugi d'ell.</li> <li>Crea els punts de cerca i la l\u00f2gica de moviment per als altres fantasmes.</li> <li>Assigna a cada fantasma un comportament diferent, segons la IA original del joc: IA del Pacman</li> </ul>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.3.%20Pathfinding%202D%20amb%20f%C3%ADsiques/","title":"2.3 Pathfinding 2D amb f\u00edsiques","text":"<p>En aquesta secci\u00f3, implementarem el pathfinding 2D utilitzant el paquet A* Pathfinding Project vist anteriorment, per\u00f2 aquesta vegada aprofitant les capacitats de les f\u00edsiques 2D de Unity per a la detecci\u00f3 d'obstacles.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.3.%20Pathfinding%202D%20amb%20f%C3%ADsiques/#configuracio-del-projecte","title":"Configuraci\u00f3 del projecte","text":"<p>Descarregaa el projecte de Github des de aquest enlla\u00e7 i obriu-lo amb Unity.</p> <p></p> <p>Al igual que en el projecte anterior, hem d'instalar el paquet A* Pathfinding Project. Si no ho heu fet encara, seguiu els passos descrits en la secci\u00f3 anterior per a instal\u00b7lar-lo.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.3.%20Pathfinding%202D%20amb%20f%C3%ADsiques/#seguiment-sense-pathfinding","title":"Seguiment sense pathfinding","text":"<p>Sense utilitzar algorismes de pathfinding, podem fer que un objecte seguisca a un altre.</p> <p>Obre l'script Enemigo.cs i afegeix la seg\u00fcent propietat p\u00fablica per a l'objectiu (Personaje):</p> <pre><code>public Transform player;\n</code></pre> <p>En el m\u00e8tode <code>Update()</code>, afegeix el seg\u00fcent codi per a moure l'enemic cap al jugador:</p> <pre><code>void Update()\n{\nVector3 targetPosition = new Vector3(player.position.x, player.position.y, transform.position.z);\ntransform.position = Vector3.Lerp(transform.position, targetPosition, speed * Time.deltaTime);    }\n</code></pre> <p>Info</p> <p>El m\u00e8tode <code>Vector3.Lerp()</code> permet interpolar entre dues posicions. En aquest cas, mou l'enemic cap a la posici\u00f3 del jugador a una velocitat determinada per la variable <code>speed</code>.</p> <p>Posa en marxa el joc. Veur\u00e0 que, encara que l'enemic va cap al jugador, no pot evitar els obstacles i es queda atrapat.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.3.%20Pathfinding%202D%20amb%20f%C3%ADsiques/#afegir-component-de-pathfinding","title":"Afegir component de pathfinding","text":"<p>Anem a afegir el component de pathfinding al nostre escenari igual que en el cas anterior.Primer creem un GameObject buit. Nomeneu-lo \"A*\".</p> <p>Seleccioneu el GameObject \"A*\" i feu click a \"Add Component\". Cerqueu \"Pathfinder\" i afegiu-lo.</p> <p>Dins del component Pathfinder, feu click a Graphs -&gt; Add New Graph -&gt; Grid Graph.</p> <p>Dins de les propietats del Grid Graph, ajusteu els seg\u00fcents par\u00e0metres:</p> <ul> <li>Grid Graph 2D: activat</li> </ul> <p>Ara apareixer\u00e0 una graella sobre el vostre escenari. Ajusteu la mida i la posici\u00f3 de la graella perqu\u00e8 cobreixi tota l'\u00e0rea on voleu que els personatges es puguen moure, usant l'eina scale.</p> <p>Configureu tamb\u00e9  les seg\u00fcents opcions:</p> <ul> <li>Connections: Eight. Aix\u00f2 far\u00e0 que cada quadrat de la graella estigui connectat nom\u00e9s amb els seus 8 ve\u00efns (dalt, baix, esquerra, dreta i les 4 diagonals).</li> <li>Cut Corners: activat. Aix\u00f2 permetr\u00e0 que els personatges puguin moure's en diagonal al voltant dels obstacles.</li> <li>Use 2D Physics: activat. Aix\u00f2 far\u00e0 que el pathfinding utilitzi la f\u00edsica 2D per detectar obstacles.</li> <li>Collider type: Sphere.</li> <li>Diameter: 1.5. Aix\u00f2 defineix la mida de l'esfera que s'utilitzar\u00e0 per detectar col\u00b7lisions amb obstacles.</li> <li>Height testing: desactivat. Aix\u00f2 desactiva la comprovaci\u00f3 d'altura, ja que estem treballant en 2D.</li> </ul> <p>Un cop fet aix\u00f2, feu click a \"Scan\" per generar el graf de navegaci\u00f3. Us haur\u00e0 generat una graella blava sobre l'escenari amb els possibles camins.</p> <p>Ara, seleccioneu el pardal i afegiu-li els components Seeker i AIPath.</p> <p>En el component AIPath, configureu els seg\u00fcents par\u00e0metres:</p> <ul> <li>Orientation: Y-axis forward (for 2D games).</li> <li>Max Speed: 5.</li> <li>Enable rotation: desactivat.</li> </ul> <p>Ara afegiu el component \"AI Destination Setter\" i afegiu-lo. Afegiu el gameobject Pacman al camp Target del component.</p> <p>En l'script <code>Enemigo.cs</code>, elimineu el codi del m\u00e8tode <code>Update()</code> que hav\u00edem afegit anteriorment per a seguir al jugador. Poseu en marxa el joc. Veureu que el comportament del pardal \u00e9s el mateix que abans. Aix\u00f2 \u00e9s perqu\u00e8 no hem indicat la capa d'obstacles als components de pathfinding.</p> <p>Seleccioneu les plataformes, els murs i el s\u00f2l i assegureu-vos que tenen el Layer assignat a Obstacle. Ara en el component Grid Graph, configureu els seg\u00fcents par\u00e0metres addicionals:</p> <ul> <li>Obstacle layer mask: Obstacle.</li> </ul> <p>Torna a fer click a \"Scan\" per actualitzar el graf de navegaci\u00f3 amb la nova capa d'obstacles. Ajusta la graella si cal. Comprova que el pardal ara evita els obstacles quan segueix al personatge.</p> <p></p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.3.%20Pathfinding%202D%20amb%20f%C3%ADsiques/#pathfinding-2d-amb-fisiques","title":"Pathfinding 2D amb f\u00edsiques","text":"<p>En aquest apartat usarem el nostre propi codi per a implementar el pathfinding 2D amb f\u00edsiques.</p> <p>Fes una c\u00f2pia de l'enemic i desactiva l'Enemic original. Treballarem amb la c\u00f2pia. Deslliga la c\u00f2pia del prefab original: selecciona la c\u00f2pia i fes click dret -&gt; Unpack Prefab Completely.</p> <p>En la c\u00f2pia, elimina els components AIPath i AI Destination Setter, per\u00f2 ment\u00e9n el component Seeker.</p> <p>Posa en marxa el joc. El pardal hauria de estar est\u00e0tic perqu\u00e8 no t\u00e9 cap codi per a moure's ni gravetat.</p> <p>Obre l'script <code>Enemigo.cs</code> i afegeix la seg\u00fcent l\u00ednia a la part superior per a incloure el namespace del paquet A* Pathfinding Project:</p> <pre><code>using Pathfinding;\n</code></pre> <p>Despr\u00e9s crearem una propietat p\u00fablica per al pr\u00f2xim punt de cerca (dist\u00e0ncia a partir de la qual cercar\u00e0 el pr\u00f2xim punt), dins de la classe <code>Enemigo</code>:</p> <pre><code>public float nextWaypointDistance = 3f;\n</code></pre> <p>Tamb\u00e9 necessitarem propietats privades per al cam\u00ed (<code>Path</code>), per al punt actual del cam\u00ed i un boole\u00e0 per saber si hem arribat al final del cam\u00ed. Tamb\u00e9 necessitarem una refer\u00e8ncia al component <code>Seeker</code> i al Rigidbody2D per a moure l'enemic:</p> <pre><code>private Rigidbody2D rb;\nprivate Path path;\nprivate Seeker seeker;\nprivate int currentWaypoint = 0;\nprivate bool reachedEndOfPath = false;\n</code></pre> <p>A continuaci\u00f3, inicialitzarem la refer\u00e8ncia al <code>Seeker</code> dins del m\u00e8tode <code>Start()</code> i comen\u00e7arem a cercar el cam\u00ed cap a l'objectiu usant el m\u00e8tode <code>StartPath()</code> on indiquem la posici\u00f3 inicial, la posici\u00f3 final i la funci\u00f3 que es cridar\u00e0 quan s'acabe de calcular el cam\u00ed:</p> <pre><code>void Start()\n{\nrb = GetComponent&lt;Rigidbody2D&gt;();\nseeker = GetComponent&lt;Seeker&gt;();\nseeker.StartPath(transform.position, player.position, OnPathComplete);\n}\n</code></pre> <p>Ara creem el m\u00e8tode <code>OnPathComplete()</code> que s'encarregar\u00e0 de rebre el cam\u00ed calculat i assignar-lo a la propietat <code>path</code>. Tamb\u00e9 reiniciarem l'\u00edndex del punt actual del cam\u00ed:</p> <pre><code>public void OnPathComplete(Path p)\n{\n// The path is now calculated!\n\n//Check for errors\nif (p.error)\n{\nDebug.LogError(\"Error calculating path: \" + p.errorLog);\nreturn;\n}\n\npath = p; // Store the calculated path\ncurrentWaypoint = 0; // Reset waypoint index\n\n}\n</code></pre> <p>En l'inspector de Unity, assigna el Personatge a la propietat Target del pardal. Assigna tamb\u00e9 una velocitat de 100. Posa en marxa el joc i comprova que es dibuixa el cam\u00ed des del pardal fins al personatge. Per\u00f2 de moment aquest no s'actualitza.</p> <p>Per a que es moga, hem de treballar en el m\u00e8tode <code>Update()</code>. Afegim el seg\u00fcent codi per a moure l'enemic al llarg del cam\u00ed:</p> <pre><code>void Update()\n{\nif (path == null)\nreturn;\n</code></pre> <p>SI no tenim un cam\u00ed, no seguim endavant.</p> <pre><code>    if (currentWaypoint &gt;= path.vectorPath.Count)\n{\nreachedEndOfPath = true;\nreturn;\n}\nelse\n{\nreachedEndOfPath = false;\n}\n</code></pre> <p>Aquest codi serveix per a comprovar si hem arribat al final del cam\u00ed. Si l'\u00edndex del punt actual \u00e9s major o igual que el nombre de punts en el cam\u00ed, hem arribat al final. Marquem <code>reachedEndOfPath</code> com a cert i sortim del m\u00e8tode.</p> <pre><code>    Vector2 direction = ((Vector2)path.vectorPath[currentWaypoint] - rb.position).normalized;\nVector2 force = direction * (speed * Time.deltaTime);\n\nrb.AddForce(force);\n</code></pre> <p>Ac\u00ed estem calculant la direcci\u00f3 cap al seg\u00fcent punt del cam\u00ed i aplicant una for\u00e7a al Rigidbody2D per a moure'l en aquesta direcci\u00f3.</p> <pre><code>    var distance = Vector2.Distance(rb.position, path.vectorPath[currentWaypoint]);\nif (distance &lt; nextWaypointDistance)\n{\ncurrentWaypoint++;\n}\n</code></pre> <p>Per \u00faltim, comprovem si hem arribat prou a prop del punt actual del cam\u00ed. Si la dist\u00e0ncia \u00e9s menor que <code>nextWaypointDistance</code>, incrementem l'\u00edndex del punt actual per a passar al seg\u00fcent punt del cam\u00ed.</p> <p>Al posar en marxa el joc, el pardal hauria de moure's cap al personatge. Per\u00f2 no frena ni actualitza el cam\u00ed quan canvia la posici\u00f3 del personatge. Per a solicionar el tema del moviment, canvia el valor de Linear Damping del Rigidbody2D a 1 o 2. Prova tamb\u00e9 amb diversos valors per a la velocitat.</p> <p>Per a actualitzar el cam\u00ed, hem de cridar el m\u00e8tode <code>StartPath()</code> del <code>seeker</code> peri\u00f2dicament. Hem de crear una nova funci\u00f3 amb eixe prop\u00f2sit:</p> <pre><code>void UpdatePath()\n{\nif(seeker.IsDone())\nseeker.StartPath(transform.position, player.position, OnPathComplete);\n}\n</code></pre> <p>Aquesta \u00e9s la l\u00ednia de codi que teniem en el m\u00e8tode <code>Start()</code> (junt amb una comprovaci\u00f3 del <code>seeker</code>), per\u00f2 ara la cridarem peri\u00f2dicament. Per a fer-ho, podem utilitzar el m\u00e8tode <code>InvokeRepeating()</code> dins del m\u00e8tode <code>Start()</code>:</p> <pre><code>InvokeRepeating(\"UpdatePath\", 0f, 0.2f);\n</code></pre> <p>Aquesta l\u00ednia cridar\u00e0 el m\u00e8tode <code>UpdatePath()</code> cada 0.2 segons a partir del moment 0.</p> <p>Ara el pardal hauria de seguir al personatge evitant els obstacles i actualitzant el cam\u00ed quan el personatge es mou.</p> <p>L'\u00faltim pas \u00e9s assegurar-nos que el pardal gira en la direcci\u00f3 del moviment. Per a aix\u00f2, afegim el seg\u00fcent codi al final del m\u00e8tode <code>Update()</code>:</p> <pre><code>if (rb.linearVelocityX &lt; -0.01f)\n{\ntransform.localScale = new Vector3(1f, 1f, 1f);\n}\nelse if (rb.linearVelocityX &gt; 0.01f)\n{\ntransform.localScale = new Vector3(-1f, 1f, 1f);\n}\n</code></pre> <p>Aquest codi gira el pardal cap a l'esquerra o cap a la dreta segons la velocitat en l'eix X del Rigidbody2D.</p>"},{"location":"U02.%20%20IA%20i%20aprenentatge%20autom%C3%A0tic/2.3.%20Pathfinding%202D%20amb%20f%C3%ADsiques/#tasques","title":"Tasques","text":"<ul> <li>Afegir mode patrulla: Fes que l'enemic patrulle per una s\u00e8rie de punts (2 o 3) quan el personatge no est\u00e0 a prop. Quan el personatge s'acoste prou, que comence a seguir-lo utilitzant el pathfinding.</li> <li>Fes que l'enemic estiga en mode patrulla entre 2 punts. Quan passe un cert temps, canvieu el punt de destinaci\u00f3 a un altre \u00e0rea de patrulla. Si en algun moment el personatge s'acosta prou, que l'enemic comence a seguir-lo. Si el personatge s'allunya, que l'enemic torne al mode patrulla.</li> </ul>"}]}